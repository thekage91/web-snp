
In this chapter, we will explain creation of database, from code point of view and design point of view. As explained in introduction chapter, the impl
lementaion of the database is made using MongoDB, the noSQL DBMS, through mongoose, the JavaScript interface beetween the program and the database.
\\
The approach followed by this technique allows a more efficient way of handling those objects. In fact, using mongoose's schemas to define objects of the\\
database, permits to treat database models like any JavaScript object. To achieve this, MongoDB uses documents, a set of key-value pairs, stored in \\
collections, held by a database. 
\\
In the following part, we will see objects that form our database model.

\section{Mongoose's syntax}
To realize an object using mongoose, we need to follow a specific syntax. \\* First of all, you must place all model files related to the diagrams of the model in a specific folder within the project. Each of these files must be placed in a specific folder within the project /server/models/.//
At the beginning of each file, we need to inform the database of the fact that any values ​​passed to the builders of the models, which are not present in the schema should not be persisted. We do this by defining a string \mbox{}\verb@ 'use strict'@\\.
then you must specify the modules dependencies required to create the schema. In our case, we must satisfy the dependency on the modules (bold type) 'mongoose' and 'crypto (a module for encrypting information.) \\*   

We do this through the following code: 


\begin{lstlisting}      
var mongoose = require('mongoose'),
Schema = mongoose.Schema,
crypto = require('crypto');
\end{lstlisting}

At this point you switch to define the schema itself, which consists of all the necessary components for the definition of the object in question, with the attributes and relationships. Note that mongo automatically adds an ID fileld for each schema defined, and assigns it following an internal policy.
The syntax for doing this is explicated in the example, where it is supposed to want to model a user with an attribute \textbf{name} of type string: 

\begin{lstlisting} 

UserSchema = new Schema ({
  / / attribute
  name: {
         type: String,
         required: true,
         validate: [validatePresenceOf, 'Name can not be blank']
     },

    / / relationship
   patiens: [{
   type: Schema.Type.ObjectId,
   ref: 'Patient'
   }]
     ); 
\end{lstlisting}

Next, you can define a number of additional features to our model, such as

\begin{itemize}
	\item Validations: functions called to validate a set of attributes or data specified by the programmer
	\item Virtuals: virtual attributes, ie not persisted
	\item Pre-save hooks: functions called at the time immediately before the model is saved to the 				database
	\item Methods: all methods necessary for the operation of our model. 
\end{itemize}

Finally, one must specify the actual name of the model from which the schema specified as previously shown, in addition to its creation proocedere real. We do this through the following code:

\begin{lstlisting}
	mongoose.model ('User', UserSchema);
\end{lstlisting}

\section{Model Schemas}

\subsection{Family}
A Family represents a set of one or more patients (modeled in patient schema). It can be created only by an user with admin privileges. This schema allow to group patients with similar genomic mutations as well as real families (father, mother, son {..} ). \\*
Here it is the code to implement the family object: 

\lstinputlisting{../server/models/family.js}

\newpage 

\paragraph{Attributes}      
\begin{itemize}
 	\item \textbf{name:} it describes family's name
\end{itemize}

\paragraph{Relationships}   
\begin{itemize}
 	\item \textbf{patients:} links family to its members
\end{itemize}

\subsection{Variants}
The table variants is what is the key concept that we want to model in our project, namely the real genomic variants; This table will always be accessed in fact during the consultation phase, where the biologist can search or include such variations, which will be stored in the table. The database is connected to almost all the tables, the fact that testifies to the centrality of his role. \\*\\*
To implement that table we use the following code:

\lstinputlisting{../server/models/variant.js}
 
\newpage

\paragraph{Attributes}      
\begin{itemize}
 	\item \textbf{chr:}  it's a five-characters string that //......NON E FINITO
 	\item \textbf{start,end:} integers that describe the coordinate of the mutation within the chromosome; 			if they match, it means that we are dealing with a point mutation
	 \item \textbf{ref:} represents the correct basis, that is what should be  if there were no mutation
   	\item \textbf{alt:} represents what we find is actually due to the mutation; one. or - represent a 				deletion, while a sequence, for example CTTG ..., represents an insertio
\end{itemize}

\paragraph{Relationships}   
\begin{itemize}
	\item \textbf{gene:} links the variant with the gene affected by the change
	\item \textbf{pathogenicity:} describes the variant pathogenicity, that is if the variant cause diseases
  	\item \textbf{patients:} links patients affected by that varant
  	\item \textbf{dbSNPs:} connects the variant to its dbSNPs
  	\item \textbf{esps:} BOH - YEAH
  	\item \textbf{sequencings:} all sequencings affected by this variation
\end{itemize}
 




