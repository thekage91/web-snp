<!DOCTYPE html>
<html>
 <head> 
  <title>Widget</title> 
  <style>
    body{
      margin: 0;
      overflow: hidden;
    }
    #menu {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
      }
    #stats {  /* Align stats top-left */
      position: absolute;
      left: 0px;
      top: 0px;
    }
    button {
        color: rgba(127,255,255,0.75);
        background: transparent;
        outline: 1px solid rgba(127,255,255,0.75);
        border: 0px;
        padding: 5px 10px;
        cursor: pointer;
      }
      button:hover {
        background-color: rgba(0,255,255,0.5);
      }
      button:active {
        color: #000000;
        background-color: rgba(0,255,255,0.75);
      }
  </style> 

  <!-- JavaScript libraries -->
  <script src="libs/jquery.min.js"></script> 
  <script src="libs/three.min.js"></script>
  <script src="libs/Stats.min.js"></script>
  <script src="libs/dat.gui.min.js"></script>
  <script src="libs/TrackballControls.js"></script>
  <script src="libs/tween.min.js"></script>
  <script src="libs/OBJLoader.js"></script>
  <script type="text/javascript" src="libs/helvetiker_regular.typeface.js"></script> 
  <script type="text/javascript" src="libs/helvetiker_bold.typeface.js"></script> 
  <script type="text/javascript" src="libs/bitstream_vera_sans_mono_roman.typeface.js"></script>
  <script src="libs/keyframe.js"></script>
  <script src="libs/CurveExtras.js"></script>

  <script src="adenine.js"></script>
  <script src="cytosine.js"></script>
  <script src="thymine.js"></script>
  <script src="guanine.js"></script>
  </head>

  <body>

    <div id="menu">
      <button id="animation">Show Animation</button>
    </div>
  <!-- Javascript code that runs our Three.js examples --> 
  <script>
    // once everything is loaded, we run our Three.js stuff.
    $(function () {

      var stats = initStats();

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene();

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

      // create trackball controls
      var trackballControls = new THREE.TrackballControls(camera);

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer();
      //webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0));
      webGLRenderer.setClearColor(new THREE.Color(0x303739, 1.0));
      webGLRenderer.setSize(window.innerWidth, window.innerHeight);

      // position and point the camera to the center of the scene
      camera.position.set(0, 0, 500);
      camera.lookAt(new THREE.Vector3(0, 0, 0));


      // add the output of the renderer to the html element
      $('body').append(webGLRenderer.domElement);



      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      function createMesh(geom, textColor) {
        var meshMaterial = new THREE.MeshPhongMaterial({specular: 0xffffff, color: textColor, shininess: 100, metal: true});
        var textMesh = new THREE.Mesh(geom, meshMaterial);
        textMesh.castShadow = true;

        return textMesh;
      }

      //Function to create a couple of nitrogenous bases
      //function createCouple (baseLeft, baseRight) {
      function createCouple () {
        //Per test; quando ci saranno i costruttori chiamare i costruttori in base ai parametri
        var couple = new THREE.Object3D();

        var baseLBase = createGuanine();

        baseLBase.rotation.z = Math.PI/2;

        baseLBase.position.set(0, -basesLength + basesRadius/2, 0);
        baseLBase.castShadow = true;

        couple.add(baseLBase);

        var baseLBallGeometry = new THREE.SphereGeometry( basesRadius*2, 32, 32 );
        var baseLBallMaterial = new THREE.MeshBasicMaterial( {color: 0xff3200} );
        var baseLBall = new THREE.Mesh(baseLBallGeometry, baseLBallMaterial);
        baseLBall.position.set(-basesRadius, -basesLength - basesRadius*2 + basesRadius/2, basesRadius);
        baseLBall.castShadow = true;


        var baseRBase = createCytosine();

        baseRBase.rotation.z = Math.PI/2;

        baseRBase.position.set(0, 0, 0);
        baseRBase.castShadow = true;

        couple.add(baseRBase);

        var baseRBallGeometry = new THREE.SphereGeometry( basesRadius*2, 32, 32 );
        var baseRBallMaterial = new THREE.MeshBasicMaterial( {color: 0x007bff} );
        var baseRBall = new THREE.Mesh(baseRBallGeometry, baseRBallMaterial);
        baseRBall.position.set(-basesRadius, basesLength + basesRadius*2, basesRadius);
        baseRBall.castShadow = true;

        var baseRPlaneGeometry = new THREE.BoxGeometry( basesRadius*8, basesRadius, basesRadius );
        var baseRPlaneMaterial = new THREE.MeshBasicMaterial( {color: 0x007bff} );
        var baseRPlane = new THREE.Mesh(baseRPlaneGeometry, baseRPlaneMaterial);
        baseRPlane.position.set(-basesRadius*4, 0, 0);
        baseRPlane.castShadow = true;

        var baseLPlaneGeometry = new THREE.BoxGeometry( basesRadius*8, basesRadius, basesRadius );
        var baseLPlaneMaterial = new THREE.MeshBasicMaterial( {color: 0xff3200} );
        var baseLPlane = new THREE.Mesh(baseLPlaneGeometry, baseLPlaneMaterial);
        baseLPlane.position.set(-basesRadius*4, 0, 0);
        baseLPlane.castShadow = true;

        baseLBall.rotation.y = Math.PI*1/3;
        baseLBall.rotation.x = -Math.PI*1/15;
        baseRBall.rotation.y = -Math.PI*1/3;
        baseRBall.rotation.x = -Math.PI*1/15;

        //couple.add(baseLBall);
        //couple.add(baseRBall);
        //baseRBall.add(baseRPlane);
        //baseLBall.add(baseLPlane);
        
        return couple;
      }


      //Function to create the supercoil
      function createSupercoil(numberOfElements) {  //Per passare le basi delle singole coppie, aggiungere come parametro una lista di liste
        var supercoil = new THREE.Object3D();
        // positionsObj rappresenta l'array di coppie dove poi le basi azotate andranno dopo l'animazione
        positionsObj = [];

        var previous = createCouple();

        positionsObj.push(previous);
        supercoil.add(previous);

        for (var i = 0; i < numberOfElements - 1; i++) {
          var currentCouple = createCouple();

          currentCouple.position.x += basesRadius*4;
          currentCouple.rotation.x = Math.PI*1/6;

          previous.add(currentCouple);

          previous = currentCouple;
          positionsObj.push(previous);
        }

        return supercoil;
      }


      //Function to create an adenine base
      function createAdenine() {
        var shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.lineTo(0, basesRadius*2);
        shape.lineTo(basesLength/2, basesRadius*2);
        shape.arc(0, 0, basesRadius/2, 2*Math.PI, Math.PI, false);
        shape.lineTo(basesLength - basesRadius, basesRadius*2);
        shape.moveTo(basesLength - basesRadius, basesRadius);
        shape.arc(0, 0, basesRadius, -Math.PI/2, Math.PI/2, false);
        shape.lineTo(0, 0);

        var shapeGeometry = shape.extrude({amount: basesRadius*2, bevelSize: 0, bevelThickness: 0});
        var shapeMaterial = new THREE.MeshBasicMaterial({color: 0xfc9362, side: THREE.DoubleSide});
        var shape = new THREE.Mesh(shapeGeometry, shapeMaterial);

        shape.castShadow = true;
        shape.receiveShadow = true;

        var adenine = new THREE.Object3D();
        adenine.add(shape);

        //TODO: Mettere bordi neri
        //shape.wireframe = new THREE.MeshBasicMaterial({color: 0x000000, side: THREE.DoubleSide});
        //shape.wireframeLinewidth = 50;
        //shape.wireFrameLineJoin = meshMaterial.wireframeLinejoin;
        
        //Add the text "A"
        var text = createMesh(new THREE.TextGeometry("A", options), 0x396d35);
        text.position.z = basesRadius*3/2;
        text.position.y = basesRadius/3;
        text.position.x = basesLength - basesRadius*3;

        text.castShadow = true;
        text.receiveShadow = true;

        adenine.add(text);

        return adenine;
      }


      //Function to create a guanine base
      function createGuanine() {
        var shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.lineTo(0, basesRadius*2);
        shape.lineTo(basesLength/2, basesRadius*2);
        shape.arc(0, 0, basesRadius/2, 2*Math.PI, Math.PI, false);
        shape.lineTo(basesLength - basesRadius, basesRadius*2);
        shape.lineTo(basesLength, basesRadius);
        shape.lineTo(basesLength - basesRadius, 0);
        shape.lineTo(0, 0);

        var shapeGeometry = shape.extrude({amount: basesRadius*2, bevelSize: 0, bevelThickness: 0});
        var shapeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide});
        var shape = new THREE.Mesh(shapeGeometry, shapeMaterial);

        shape.castShadow = true;
        shape.receiveShadow = true;

        var guanine = new THREE.Object3D();
        guanine.add(shape);

        //TODO: Mettere bordi neri
        //shape.wireframe = new THREE.MeshBasicMaterial({color: 0x000000, side: THREE.DoubleSide});
        //shape.wireframeLinewidth = 50;
        //shape.wireFrameLineJoin = meshMaterial.wireframeLinejoin;
        
        //Add the text "G"
        var text = createMesh(new THREE.TextGeometry("G", options), 0x396d35);
        text.position.z = basesRadius*3/2;
        text.position.y = basesRadius/3;
        text.position.x = basesLength - basesRadius*3;

        text.castShadow = true;
        text.receiveShadow = true;

        guanine.add(text);

        return guanine;
      }


      //Function to create a cytosine base
      function createCytosine() {
        var shape = new THREE.Shape();
        shape.moveTo(0, basesRadius*2);
        shape.lineTo(basesRadius, basesRadius);
        shape.lineTo(0, 0);
        shape.lineTo(basesLength, 0);
        shape.lineTo(basesLength, basesRadius*2);
        shape.lineTo(0, basesRadius*2);

        var shapeGeometry = shape.extrude({amount: basesRadius*2, bevelSize: 0, bevelThickness: 0});
        var shapeMaterial = new THREE.MeshBasicMaterial({color: 0xdda411, side: THREE.DoubleSide});
        var shape = new THREE.Mesh(shapeGeometry, shapeMaterial);

        shape.castShadow = true;
        shape.receiveShadow = true;

        var cytosine = new THREE.Object3D();
        cytosine.add(shape);

        //TODO: Mettere bordi neri
        //shape.wireframe = new THREE.MeshBasicMaterial({color: 0x000000, side: THREE.DoubleSide});
        //shape.wireframeLinewidth = 50;
        //shape.wireFrameLineJoin = meshMaterial.wireframeLinejoin;
        
        //Add the text "C"
        var text = createMesh(new THREE.TextGeometry("C", options), 0x396d35);
        text.position.z = basesRadius*3/2;
        text.position.y = basesRadius/3;
        text.position.x = basesRadius*2;

        text.castShadow = true;
        text.receiveShadow = true;

        cytosine.add(text);

        return cytosine;
      }


      //Function to create a thymine base
      function createThymine() {
        var shape = new THREE.Shape();
        shape.moveTo(0, basesRadius);
        shape.arc(0, 0, basesRadius, Math.PI/2, -Math.PI/2, false);
        shape.lineTo(basesLength, basesRadius*2);
        shape.lineTo(basesLength, 0);
        shape.lineTo(0, 0);
        
        var shapeGeometry = shape.extrude({amount: basesRadius*2, bevelSize: 0, bevelThickness: 0});
        var shapeMaterial = new THREE.MeshBasicMaterial({color: 0xffe900, side: THREE.DoubleSide});
        var shape = new THREE.Mesh(shapeGeometry, shapeMaterial);

        shape.castShadow = true;
        shape.receiveShadow = true;

        var thymine = new THREE.Object3D();
        thymine.add(shape);

        //TODO: Mettere bordi neri
        //shape.wireframe = new THREE.MeshBasicMaterial({color: 0x000000, side: THREE.DoubleSide});
        //shape.wireframeLinewidth = 50;
        //shape.wireFrameLineJoin = meshMaterial.wireframeLinejoin;
        
        //Add the text "T"
        var text = createMesh(new THREE.TextGeometry("T", options), 0x396d35);
        text.position.z = basesRadius*3/2;
        text.position.y = basesRadius/3;
        text.position.x = basesRadius*2;

        text.castShadow = true;
        text.receiveShadow = true;

        thymine.add(text);

        return thymine;
      }




      //VARIABLES
      var basesLength = 50;
      var basesRadius = 5;

      var options = {
        size: 7,
        height: basesRadius*2/3,
        font: "helvetiker",
        bevelThickness: 1,
        bevelSize: 0.5,
        bevelSegments: 3,
        bevelEnabled: true,
        curveSegments: 12,
        steps: 1
      };
      
      var axisHelper = new THREE.AxisHelper(3);
      scene.add(axisHelper);
        
      DNA = createSupercoil(31);
      fooCouple = createCouple();
      scene.add(fooCouple);
      //scene.add(DNA);

      //var temp = createAdenine();
      var temp = createGuanine();
      var temp2 = createCytosine();
      temp2.position.x = basesLength - basesRadius;

      //scene.add(temp);
      //scene.add(temp2);

      var temp3 = createThymine();
      //scene.add(temp3);


      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


      /*------------------------------------------------- PROVA ----------------------------------------------------*/

      var segments = 400;
      var tubeRadius = 3.5;
      var radiusSegments = 12;
      globalStructure = new THREE.Object3D();

      extrudePath = new THREE.Curves.HelixCurve();

      tube = new THREE.TubeGeometry(extrudePath, segments, tubeRadius, radiusSegments, false, false);

      var tubeMesh1 = addGeometry(tube, 0xff3200);
      setScale();
      tubeMesh1.rotation.y = Math.PI/2;
      tubeMesh1.rotation.z = -Math.PI/2;

      tubeMesh1.position.x += -tubeRadius;

      var tubeMesh2 = addGeometry(tube, 0x007bff);
      setScale();
      tubeMesh2.rotation.y = Math.PI/2;
      tubeMesh2.rotation.z = Math.PI/2;

      tubeMesh2.position.x += -tubeRadius;
      
      DNA.position.x += basesRadius/2;

      globalStructure.add(DNA);
      globalStructure.add(tubeMesh1);
      globalStructure.add(tubeMesh2);

      scene.add(globalStructure);

      animate();

      function addGeometry( geometry, color ) {

        // 3d shape

        tubeMesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [
          new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            side: THREE.DoubleSide
          }),
          new THREE.MeshBasicMaterial({
            color: 0xed3403,
            opacity: 0.3,
            //wireframe: true,
            transparent: true
        })]);

        return tubeMesh;

      }

      // funzione che crea un array random di object3d per sparpagliare le basi azotate
      // una volta che si clicca sul tasto animate
      function randomizePositionObject(){

          var randomObjPositions = [];
          var randomObj = new THREE.Object3D();

          for(var i = 0; i < 31; i++){
            var x = Math.random() * 4000 - 2000;
            var y = Math.random() * 4000 - 2000;
            var z = Math.random() * 4000 - 2000;
            randomObj.position.set(x,y,z);
            randomObjPositions.push(randomObj);
          }
          return randomObjPositions;
      }

      function transform(objects, targets, duration ) {

        TWEEN.removeAll();

        for ( var i = 0; i < objects.length; i ++ ) {

          var object = objects[ i ];
          var target = targets[ i ];

          new TWEEN.Tween( object.position )
            .to( { x: target.position.x, y: target.position.y, z: target.position.z }, duration )
            .easing( TWEEN.Easing.Exponential.InOut )
            .start();

          new TWEEN.Tween( object.rotation )
            .to( { x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, duration )
            .easing( TWEEN.Easing.Exponential.InOut )
            .start();

        }

      }

      function setScale() {

        scale = 2;
        tubeMesh.scale.set( scale, scale, scale );

      }
      /*------------------------------------------------------------------------------------------------------------*/
      /*var button = document.getElementById( 'animation' );
      button.addEventListener( 'click', function ( event ) {

        animateScene(2000 );

      }, false );*/


      function movingCamera(duration){

        var target = new THREE.Vector3(0,0,300);
        camera.lookAt(new THREE.Vector3(0,0,400));

        new TWEEN.Tween( camera.position )
            .to( { x: target.x, y: target.y, z: target.z }, duration )
            .easing( TWEEN.Easing.Quadratic.In )
            .start();
      }

      // Le basi rigurdanti saranno le numero 15, per esempio
      function aniateSNP(duration){

        var couple = positionsObj[15];
        // couple.childer[0] e' la prima base azotate
        // couple.childer[1] e' la seconda base azotate
        // couple.childer[2] sono tutte quelle che vengono dopo

        var target = new THREE.Vector3(0,0,30);

        var movingForward1 = new  new TWEEN.Tween( couple[0].position )
            .to( { z: target.z }, duration )

        var movingForward2 = new TWEEN.Tween( couple[1].position )
            .to( { z: target.z }, duration )
            .easing( TWEEN.Easing.Quadratic.In )
            .chain(movingForward1)
            .start();

        /* in questo punto dovrebbero comparire due nuove basi azotate vicino quuelle vecchie che si
        sono spostate avanti. Per far questo basta usare la funzione trasforms.... 
        passndo un array (object) contenente le due nuove basi disperse da qualche parte
        e un altro array (targets) che rappresenta la nuova posizione delle nuove basi azotate, ovvero vicino 
        a quelle vecchie. Potrebbe essere (xVecchie + 10 , 0,30)
        */

        var newPosition = new THREE.Vector3(10,0,0); //posizione nuova per le vecchie basi
        var oldPosition = new THREE.Vector3(couple[0].position.x , 0,0); // posizione nuova per le basi appena entrate

        /* le basi vecchie si spostano */
        var removeOldBase1 = new  new TWEEN.Tween( couple[0].position )
            .to( { x: newPosition.x}, duration );

        var removeOldBase2 = new  new TWEEN.Tween( couple[1].position )
            .to( { x: newPosition.x}, duration );
        /***********/

        /* Le nuove basi si mettono al posto di quelle vecchie */
        var  putNewBase1 = new  new TWEEN.Tween( new_couple[0].position )
            .to( { x: oldPosition.x}, duration );

        var putNewBase2 = new TWEEN.Tween( new_couple[1].position )
            .to( { x: oldPosition.x }, duration )
            .easing( TWEEN.Easing.Quadratic.In )
            .chain(movingForward1)
            .chain()
            .start();
        /***********/
      }

      function animateScene(duration){

        var targetPos = randomizePositionObject();
        var subjectPos = positionsObj;

        movingCamera(2000); // la camera di sposta
        // vedere come evidenziare
        transform(subjectPos , targetPos , duration); // le altre basi azotate non evidenziate vanno via (eliminare la numero 15)  
        animateSNP(2000); // si scambiano

        // rimettiamo le cose al loro posto, le altri basi tornano
        setTimeout( function() {  for(var i = 0; i < 31; i++){
                                    subjectPos[i].position = targetPos[i].position;
                                  }
                                  transform(targetPos, subjectPos, duration); 
                                } , duration);
      }

      var step = 0.01;
      function animate() {
        stats.update();
        trackballControls.update();

        globalStructure.rotation.x += step;

        TWEEN.update();
        // render using requestAnimationFrame
        requestAnimationFrame(animate);
        webGLRenderer.render(scene, camera);
      }

      function initStats() {
        var stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms
        $('body').append(stats.domElement);
        return stats;
      }
    });
  </script>
 </body>

</html>
